#!/usr/bin/env bash
set -euo pipefail

# Resolve through symlinks to find the real script directory
SOURCE="$0"
while [[ -L "$SOURCE" ]]; do
    DIR="$(cd "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ "$SOURCE" != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd "$(dirname "$SOURCE")" && pwd)"

IMAGE="speak:latest"
CONTAINER="speak-server"
PORT=9800

VOICE="Vivian"
OUTPUT=""
TEXT=""
INSTRUCT=""

usage() {
    cat <<'EOF'
Usage: speak [OPTIONS] -o OUTPUT TEXT

Generate speech from text using Qwen3-TTS.

Options:
  --voice, -v      Speaker voice (default: Vivian)
                    Available: aiden, dylan, eric, ono_anna, ryan, serena, sohee, uncle_fu, vivian
  --output, -o     Output .wav path (required)
  --instruct, -i   Voice style instruction, e.g. "whisper" or "Very happy." (optional)
  --help, -h       Show this help

Server management:
  --stop           Stop the background TTS server

Examples:
  speak -o hello.wav "Hello world"
  speak -v ryan -o greeting.wav "Hi there"
  speak -i "whisper" -o secret.wav "This is a secret"
  speak --stop
EOF
    exit 0
}

stop_server() {
    if docker container inspect "$CONTAINER" &>/dev/null; then
        docker rm -f "$CONTAINER" &>/dev/null
        echo "Server stopped." >&2
    else
        echo "Server is not running." >&2
    fi
    exit 0
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --voice|-v)
            VOICE="$2"; shift 2 ;;
        --output|-o)
            OUTPUT="$2"; shift 2 ;;
        --instruct|-i)
            INSTRUCT="$2"; shift 2 ;;
        --stop)
            stop_server ;;
        --help|-h)
            usage ;;
        -*)
            echo "Error: unknown option: $1" >&2; exit 1 ;;
        *)
            TEXT="$1"; shift ;;
    esac
done

if [[ -z "$OUTPUT" ]]; then
    echo "Error: --output/-o is required" >&2
    echo "Usage: speak [OPTIONS] -o OUTPUT TEXT" >&2
    exit 1
fi

if [[ -z "$TEXT" ]]; then
    echo "Error: no text provided" >&2
    echo "Usage: speak [OPTIONS] -o OUTPUT TEXT" >&2
    exit 1
fi

# Build image if it doesn't exist
if ! docker image inspect "$IMAGE" &>/dev/null; then
    echo "Building $IMAGE (one-time)..." >&2
    docker build -t "$IMAGE" "$SCRIPT_DIR"
fi

# Start server if not running
if ! docker container inspect "$CONTAINER" &>/dev/null; then
    echo "Starting TTS server (loading model ~30s)..." >&2
    docker run -d --gpus all --ipc=host \
        --name "$CONTAINER" \
        --entrypoint python \
        -e HF_HUB_OFFLINE=1 \
        -p "$PORT:$PORT" \
        -v "$SCRIPT_DIR:/opt/speak:ro" \
        "$IMAGE" \
        -u /opt/speak/server.py \
        > /dev/null

    # Wait for server to be ready
    while ! curl -sf "http://localhost:$PORT/health" >/dev/null 2>&1; do
        # Check if container died
        if ! docker container inspect "$CONTAINER" &>/dev/null; then
            echo "Error: server failed to start. Check: docker logs $CONTAINER" >&2
            exit 1
        fi
        sleep 1
    done
    echo "Server ready." >&2
fi

# Resolve output to absolute path
case "$OUTPUT" in
    /*) ABS_OUTPUT="$OUTPUT" ;;
    *)  ABS_OUTPUT="$(pwd)/$OUTPUT" ;;
esac

# Build JSON payload
JSON=$(printf '{"text":%s,"voice":%s,"instruct":%s}' \
    "$(printf '%s' "$TEXT" | python3 -c 'import json,sys; print(json.dumps(sys.stdin.read()))')" \
    "$(printf '%s' "$VOICE" | python3 -c 'import json,sys; print(json.dumps(sys.stdin.read()))')" \
    "$(printf '%s' "$INSTRUCT" | python3 -c 'import json,sys; print(json.dumps(sys.stdin.read()))')")

HTTP_CODE=$(curl -sf -o "$ABS_OUTPUT" -w "%{http_code}" \
    -X POST "http://localhost:$PORT/generate" \
    -H "Content-Type: application/json" \
    -d "$JSON")

if [[ "$HTTP_CODE" != "200" ]]; then
    echo "Error: server returned HTTP $HTTP_CODE" >&2
    rm -f "$ABS_OUTPUT"
    exit 1
fi

echo "Saved to $ABS_OUTPUT" >&2
